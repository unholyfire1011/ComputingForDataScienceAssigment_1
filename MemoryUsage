Python:-
import psutil
import os

LIMIT = 500000

def get_memory_usage():
    process = psutil.Process(os.getpid())
    return process.memory_info().rss / (1024 * 1024)  # MB

def main():
 
    
    start_memory = get_memory_usage()
    
    # Create large boolean list
    sieve = [True] * (LIMIT + 1)
    sieve[0] = sieve[1] = False
    
    # Sieve algorithm
    p = 2
    while p * p <= LIMIT:
        if sieve[p]:
            for i in range(p * p, LIMIT + 1, p):
                sieve[i] = False
        p += 1
    
    # Collect primes and create memory pressure
    primes = []
    extra_data = []
    
    for i in range(2, LIMIT + 1):
        if sieve[i]:
            primes.append(i)
            # Add memory pressure
            temp = [i + j for j in range(50)]
            extra_data.append(temp)
    
    peak_memory = get_memory_usage()
    
    print(f"Start memory: {start_memory:.1f} MB")
    print(f"Peak memory: {peak_memory:.1f} MB")
    print(f"Memory used: {peak_memory - start_memory:.1f} MB")

if __name__ == "__main__":
    main()

Java:-

import java.util.*;
import java.lang.management.*;

public class Main {
    static final int LIMIT = 500000;
    
    public static void main(String[] args) {
        MemoryMXBean memory = ManagementFactory.getMemoryMXBean();
        
        long startMemory = memory.getHeapMemoryUsage().getUsed() / (1024 * 1024);
     
        
        // Create large boolean array
        boolean[] sieve = new boolean[LIMIT + 1];
        Arrays.fill(sieve, true);
        sieve[0] = sieve[1] = false;
        
        // Sieve algorithm
        for (int p = 2; p * p <= LIMIT; p++) {
            if (sieve[p]) {
                for (int i = p * p; i <= LIMIT; i += p) {
                    sieve[i] = false;
                }
            }
        }
        
        // Collect primes and create memory pressure
        List<Integer> primes = new ArrayList<>();
        List<List<Integer>> extraData = new ArrayList<>();
        
        for (int i = 2; i <= LIMIT; i++) {
            if (sieve[i]) {
                primes.add(i);
                // Add memory pressure
                List<Integer> temp = new ArrayList<>();
                for (int j = 0; j < 50; j++) {
                    temp.add(i + j);
                }
                extraData.add(temp);
            }
        }
        long peakMemory = memory.getHeapMemoryUsage().getUsed() / (1024 * 1024);
        
        System.out.println("Start memory: " + startMemory + " MB");
        System.out.println("Peak memory: " + peakMemory + " MB");
        System.out.println("Memory used: " + (peakMemory - startMemory) + " MB");
    }
}

C++:-
#include <iostream>
#include <vector>
#include <fstream>

const int LIMIT = 500000;

long getMemoryUsage() {
    std::ifstream status("/proc/self/status");
    std::string line;
    while (std::getline(status, line)) {
        if (line.substr(0, 6) == "VmRSS:") {
            return std::stol(line.substr(7)) / 1024; // Convert KB to MB
        }
    }
    return 0;
}

int main() {
 
    
    long startMemory = getMemoryUsage();
 
    
    // Create large boolean vector
    std::vector<bool> sieve(LIMIT + 1, true);
    sieve[0] = sieve[1] = false;
    
    // Sieve algorithm
    for (int p = 2; p * p <= LIMIT; ++p) {
        if (sieve[p]) {
            for (int i = p * p; i <= LIMIT; i += p) {
                sieve[i] = false;
            }
        }
    }
    
    // Collect primes and create memory pressure
    std::vector<int> primes;
    std::vector<std::vector<int>> extraData;
    
    for (int i = 2; i <= LIMIT; ++i) {
        if (sieve[i]) {
            primes.push_back(i);
            // Add memory pressure
            std::vector<int> temp;
            for (int j = 0; j < 50; ++j) {
                temp.push_back(i + j);
            }
            extraData.push_back(temp);
        }
    }
    long peakMemory = getMemoryUsage();
    std::cout << "Start memory: " << startMemory << " MB" << std::endl;
    std::cout << "Peak memory: " << peakMemory << " MB" << std::endl;
    std::cout << "Memory used: " << (peakMemory - startMemory) << " MB" << std::endl;
    
    return 0;
}

Rust:-
const LIMIT: usize = 500_000;

fn get_memory_usage() -> usize {
    use std::fs;
    if let Ok(contents) = fs::read_to_string("/proc/self/status") {
        for line in contents.lines() {
            if line.starts_with("VmRSS:") {
                let parts: Vec<&str> = line.split_whitespace().collect();
                if parts.len() >= 2 {
                    if let Ok(kb) = parts[1].parse::<usize>() {
                        return kb / 1024; // Convert KB to MB
                    }
                }
            }
        }
    }
    0
}

fn main() {
    println!("=== Rust Memory Test ===");
    
    let start_memory = get_memory_usage();
    
    
    // Create large boolean vector
    let mut sieve = vec![true; LIMIT + 1];
    sieve[0] = false;
    if sieve.len() > 1 {
        sieve[1] = false;
    }
    
    // Sieve algorithm
    let mut p = 2;
    while p * p <= LIMIT {
        if sieve[p] {
            let mut i = p * p;
            while i <= LIMIT {
                sieve[i] = false;
                i += p;
            }
        }
        p += 1;
    }
    
    // Collect primes and create memory pressure
    let mut primes = Vec::new();
    let mut extra_data: Vec<Vec<usize>> = Vec::new();
    
    for (i, &is_prime) in sieve.iter().enumerate() {
        if is_prime && i >= 2 {
            primes.push(i);
            // Add memory pressure
            let temp: Vec<usize> = (0..50).map(|j| i + j).collect();
            extra_data.push(temp);
        }
    }
    

    let peak_memory = get_memory_usage();
    
  
    println!("Start memory: {} MB", start_memory);
    println!("Peak memory: {} MB", peak_memory);
    println!("Memory used: {} MB", peak_memory - start_memory);
}
